## -*- encoding: utf-8 -*-
# This file was *autogenerated* from the file thicuoiky2-dapan.sagetex.sage.
from sage.all_cmdline import *   # import sage library
_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_7 = Integer(7); _sage_const_6 = Integer(6); _sage_const_5 = Integer(5); _sage_const_4 = Integer(4); _sage_const_341 = Integer(341); _sage_const_9 = Integer(9); _sage_const_8 = Integer(8); _sage_const_264 = Integer(264); _sage_const_343 = Integer(343); _sage_const_0p85 = RealNumber('0.85'); _sage_const_275 = Integer(275); _sage_const_22 = Integer(22); _sage_const_23 = Integer(23); _sage_const_20 = Integer(20); _sage_const_21 = Integer(21); _sage_const_26 = Integer(26); _sage_const_0p6058 = RealNumber('0.6058'); _sage_const_24 = Integer(24); _sage_const_206 = Integer(206); _sage_const_135 = Integer(135); _sage_const_412 = Integer(412); _sage_const_88 = Integer(88); _sage_const_205 = Integer(205); _sage_const_2p1542 = RealNumber('2.1542'); _sage_const_0p189 = RealNumber('0.189'); _sage_const_84 = Integer(84); _sage_const_291 = Integer(291); _sage_const_86 = Integer(86); _sage_const_204 = Integer(204); _sage_const_0p9755 = RealNumber('0.9755'); _sage_const_0p1 = RealNumber('0.1'); _sage_const_173 = Integer(173); _sage_const_0p2 = RealNumber('0.2'); _sage_const_379 = Integer(379); _sage_const_1p15 = RealNumber('1.15'); _sage_const_208 = Integer(208); _sage_const_270 = Integer(270); _sage_const_383 = Integer(383); _sage_const_377 = Integer(377); _sage_const_0p1863 = RealNumber('0.1863'); _sage_const_1p21 = RealNumber('1.21'); _sage_const_1p5224 = RealNumber('1.5224'); _sage_const_13 = Integer(13); _sage_const_12 = Integer(12); _sage_const_11 = Integer(11); _sage_const_10 = Integer(10); _sage_const_17 = Integer(17); _sage_const_16 = Integer(16); _sage_const_15 = Integer(15); _sage_const_14 = Integer(14); _sage_const_9p81 = RealNumber('9.81'); _sage_const_19 = Integer(19); _sage_const_18 = Integer(18); _sage_const_25 = Integer(25); _sage_const_50 = Integer(50); _sage_const_2p8829 = RealNumber('2.8829'); _sage_const_289 = Integer(289); _sage_const_0p1929 = RealNumber('0.1929'); _sage_const_283 = Integer(283); _sage_const_385 = Integer(385); _sage_const_0p0039 = RealNumber('0.0039'); _sage_const_285 = Integer(285); _sage_const_144 = Integer(144); _sage_const_147 = Integer(147); _sage_const_140 = Integer(140); _sage_const_414 = Integer(414); _sage_const_149 = Integer(149)## This file (thicuoiky2-dapan.sagetex.sage) was *autogenerated* from thicuoiky2-dapan.tex with sagetex.sty version 2012/01/16 v2.3.3-69dcb0eb93de.
import sagetex
_st_ = sagetex.SageTeXProcessor('thicuoiky2-dapan', version='2012/01/16 v2.3.3-69dcb0eb93de', version_check=True)
_st_.blockbegin()
try:
  __tmp__=var("x"); f4 = symbolic_expression((x+_sage_const_2 /_sage_const_3 )**_sage_const_2 *(x-_sage_const_4 /_sage_const_3 )).function(x)
  x0=_sage_const_1 
  f4diff=diff(f4,x)
  __tmp__=var("x"); g1 = symbolic_expression((x**_sage_const_3 -f4(x))**(_sage_const_1 /_sage_const_3 )).function(x)
  g1=g1.expand()
  g1diff=diff(g1,x)
  g1diff2=diff(g1,x,_sage_const_2 )
except:
 _st_.goboom(_sage_const_84 )
_st_.blockend()
try:
 _st_.inline(_sage_const_0 , latex(f4(x).expand()))
except:
 _st_.goboom(_sage_const_86 )
try:
 _st_.inline(_sage_const_1 , latex(x0))
except:
 _st_.goboom(_sage_const_88 )
_st_.blockbegin()
try:
 # Tạo hàm số
 def ppnewton_raphson(f,x0=_sage_const_0 ,n=_sage_const_10 ):
  # Tính nghiệm của hàm số f(x) theo phương pháp Newton-Raphson với điểm bắt đầu là x0, tối đa n bước
  # Yêu cầu: f là hàm số một biến f(x), x0 một số thực thuộc tập xác định của f(x), n là một số nguyên dương (>0)
  # Nếu không có các tham số x0, n: lấy mặc định là x0=0, và n=10
  # Kết quả được hiển thị làm tròn đến 5 chữ số thập phân
  decipoint=_sage_const_4 
  f_diff=diff(f,x,_sage_const_1 )
  xk=range(n+_sage_const_1 )
  xk[_sage_const_0 ]=x0
  fxk=range(n)
  f_diff_xk=range(n)
  #deltaxk=range(n)
  #p_f=find_root(f,0,3) # find nearly exact root
  for i in range(n):
     fxk[i]=f(x=xk[i])
     f_diff_xk[i]=f_diff(x=xk[i])
     xk[i+_sage_const_1 ]=(f_diff_xk[i]*xk[i]-fxk[i])/f_diff_xk[i]
     #deltaxk[i]=abs(xk[i]-p_f)
  xk_disp=[round(xk[i],decipoint) for i in range(n)]
  fxk_disp=[round(fxk[i],decipoint) for i in range(n)]
  #deltaxk_disp=[round(deltaxk[i],decipoint) for i in range(n)]
  #p_f_disp=round(p_f,decipoint)
  # return fxk[n-1]
  return fxk_disp,xk_disp
 
 # Áp dụng để giải các bài toán
 n=_sage_const_5 
 fxk_disp4,xk_disp4=ppnewton_raphson(f4,x0,n)
 #fxk_disp2,xk_disp2=ppnewton_raphson(f2,1,2)
 #fxk_disp3,xk_disp3=ppnewton_raphson(f3,1,2)
 
 # Trình bày các bảng kết quả
 tableN1=r"\begin{tabular}{c|cc}"
 tableN1+=r"$k$ & $x_k$ & $f(x_k)$ \\ \hline"
 for i in range(n):
   tableN1+=latex(i) + r"&" + latex(xk_disp4[i]) + r"&" + latex(fxk_disp4[i]) + r"\\"
 tableN1+=r"\end{tabular}"
except:
 _st_.goboom(_sage_const_135 )
_st_.blockend()
try:
 _st_.inline(_sage_const_2 , tableN1)
except:
 _st_.goboom(_sage_const_140 )
try:
 _st_.inline(_sage_const_3 , latex(g1(x).expand()))
except:
 _st_.goboom(_sage_const_144 )
try:
 _st_.inline(_sage_const_4 , latex(g1diff(x).expand()))
except:
 _st_.goboom(_sage_const_144 )
try:
 _st_.inline(_sage_const_5 , latex(round(g1(x=_sage_const_1 ),_sage_const_3 )))
except:
 _st_.goboom(_sage_const_147 )
try:
 _st_.inline(_sage_const_6 , latex(round(g1(x=_sage_const_2 ),_sage_const_3 )))
except:
 _st_.goboom(_sage_const_147 )
try:
 _st_.inline(_sage_const_7 , latex(g1diff2(x)))
except:
 _st_.goboom(_sage_const_149 )
try:
 _st_.inline(_sage_const_8 , latex(round(g1diff(x=_sage_const_1 ),_sage_const_3 )))
except:
 _st_.goboom(_sage_const_149 )
try:
 _st_.inline(_sage_const_9 , latex(round(g1diff(x=_sage_const_1 ),_sage_const_3 )))
except:
 _st_.goboom(_sage_const_149 )
try:
 _st_.inline(_sage_const_10 , latex(round(g1diff(x=_sage_const_1 ),_sage_const_3 )))
except:
 _st_.goboom(_sage_const_149 )
_st_.blockbegin()
try:
 latex.matrix_delimiters("[", "]")
 A=matrix([[_sage_const_3 ,_sage_const_1 ,-_sage_const_1 ],[_sage_const_1 ,_sage_const_4 ,_sage_const_1 ],[_sage_const_1 ,-_sage_const_2 ,-_sage_const_5 ]])
 #A_rdf=matrix(RDF,[[3,1,-1],[1,4,1],[1,-2,-5]]) # lệnh tính condition() chỉ có với ma trận real-double-float, nhưng dùng ma trận RDF thì lại không giải được phương trình bằng kiểu lệnh A\B hoặc A.solve_right(B). Sẽ fix sau.
 A_rdf=matrix(RDF,A)
 B=matrix([[_sage_const_5 ],[_sage_const_4 ],[_sage_const_4 ]])
 x,y,z=var('x y z')
 X=matrix([[x],[y],[z]])
 Xp=A * BackslashOperator() * B
 #Xp=[1,2,3]
 Ainv=A.inverse()
 Ardfinv=A_rdf.inverse()
 #Ardfinv.round(3) # This will be used
 kA1=A_rdf.condition(_sage_const_1 )
 kAinf=A_rdf.condition(infinity)
except:
 _st_.goboom(_sage_const_173 )
_st_.blockend()
try:
 _st_.inline(_sage_const_11 , latex(Ainv))
except:
 _st_.goboom(_sage_const_204 )
try:
 _st_.inline(_sage_const_12 , latex(Ardfinv.round(_sage_const_3 )))
except:
 _st_.goboom(_sage_const_204 )
try:
 _st_.inline(_sage_const_13 , latex(kA1))
except:
 _st_.goboom(_sage_const_205 )
try:
 _st_.inline(_sage_const_14 , latex(kAinf))
except:
 _st_.goboom(_sage_const_206 )
try:
 _st_.inline(_sage_const_15 , latex(X))
except:
 _st_.goboom(_sage_const_208 )
try:
 _st_.inline(_sage_const_16 , latex(Xp))
except:
 _st_.goboom(_sage_const_208 )
_st_.blockbegin()
try:
 n=_sage_const_10 
 tkx=[_sage_const_0p1 *i for i in range(n+_sage_const_1 )]
 tk=[_sage_const_0p1 *i for i in range(n)]
 v0=-_sage_const_2 
 g=_sage_const_9p81 
 vt=[v0+g*tkx[i] for i in range(n+_sage_const_1 )]
 xt=[_sage_const_0  for i in range(n+_sage_const_1 )]
 for i in range(n):
  xt[i+_sage_const_1 ]=xt[i]+(vt[i+_sage_const_1 ]+vt[i])*_sage_const_0p1 /_sage_const_2 
 # Dữ liệu có sai số ngẫu nhiên
 xk=[_sage_const_0 ,-_sage_const_0p2 ,-_sage_const_0p189 ,-_sage_const_0p1929 ,_sage_const_0p0039 ,_sage_const_0p1863 ,_sage_const_0p6058 ,_sage_const_0p9755 ,_sage_const_1p5224 ,_sage_const_2p1542 ,_sage_const_2p8829 ]
 #xk=[0 for i in range(n+1)]
 #for i in range(n):
 # xk[i+1]=xt[i]+(vt[i+1]+vt[i])*0.1/2+(0.1*random()-0.05)
 # Dữ liệu chính xác
 #xk=xt
 tk2=[tk[i]**_sage_const_2  for i in range(n)]
 vk=[(xk[i+_sage_const_1 ]-xk[i])/_sage_const_0p1  for i in range(n)]
 zk=zip(tk,vk)
 plotdata=list_plot(zk, size=_sage_const_50 , legend_label='($t_k$,$v_k$)')
 matA=matrix([[n,sum(tk)],[sum(tk),sum(tk2)]])
 tkvk=[tk[i]*vk[i] for i in range(n)]
 matB=vector([sum(vk),sum(tkvk)])
 a,b=N(matA * BackslashOperator() * matB)
 t=var('t')
 hamxapxi=round(a,_sage_const_3 )+round(b,_sage_const_3 )*t
 plotline=plot(hamxapxi,_sage_const_0 ,tkx[n], color='red', legend_label='($y=A+Bt$)')
 
 tableVD5=r"\begin{tabular}{l|c|l}"
 tableVD5+=r"$k$ & $t_k$ & $v_k$ \\ \hline"
 for i in range(n):
   tableVD5+=latex(i) + r"&" + latex(round(tk[i],_sage_const_1 )) + r"&" + latex(round(vk[i],_sage_const_3 )) + r"\\"
 tableVD5+=r"\end{tabular}"
 
 tableTXk=r"\begin{tabular}{l|c|l}"
 tableTXk+=r"$k$ & $t_k$ & $x_k$ \\ \hline"
 for i in range(n+_sage_const_1 ):
   tableTXk+=latex(i) + r"&" + latex(round(tkx[i],_sage_const_1 )) + r"&" + latex(round(xk[i],_sage_const_4 )) + r"\\"
 tableTXk+=r"\end{tabular}"
 
except:
 _st_.goboom(_sage_const_264 )
_st_.blockend()
try:
 _st_.inline(_sage_const_17 , latex(n-_sage_const_1 ))
except:
 _st_.goboom(_sage_const_270 )
try:
 _st_.inline(_sage_const_18 , tableTXk)
except:
 _st_.goboom(_sage_const_275 )
try:
 _st_.inline(_sage_const_19 , tableVD5)
except:
 _st_.goboom(_sage_const_283 )
try:
 _st_.inline(_sage_const_20 , latex(hamxapxi(t)))
except:
 _st_.goboom(_sage_const_285 )
try:
 _st_.plot(_sage_const_0 , format='notprovided', _p_=plotdata+plotline)
except:
 _st_.goboom(_sage_const_289 )
try:
 _st_.inline(_sage_const_21 , latex(hamxapxi(t=_sage_const_0p85 )))
except:
 _st_.goboom(_sage_const_291 )
_st_.blockbegin()
try:
  n=_sage_const_4 
  h=_sage_const_1 /_sage_const_10 
  tk=[_sage_const_1 +h*i for i in range(n)]
  yk=range(n)
  yk[_sage_const_0 ]=_sage_const_1 
  # Tính bằng công thức lặp
  #for i in range(n-1):
  #  yk[i+1]=yk[i]+h*(yk[i]+tk[i])
  # Tính bằng Euler solver có sẵn trong Sage
  t,y=var('t y')
  from sage.calculus.desolvers import eulers_method
  zk1=eulers_method(y/t-_sage_const_1 ,tk[_sage_const_0 ],yk[_sage_const_0 ],h,tk[_sage_const_0 ]+h*(n-_sage_const_1 ),algorithm="none")
  #yk=[[j] for i,j in zk1] # Báo lỗi phía sau: lệnh latex(round(yk[i],3)) không thực hiện được (TypeError: a float is required), vì dấu [] tạo ra matrix chứ không phải list
  yk=[j for i,j in zk1]
  # Tạo table trong Latex
  tableEuler=r"\begin{tabular}{l|c|l}"
  tableEuler+=r"$k$ & $t_k$ & $y_k$ \\ \hline"
  for i in range(n):
    tableEuler+=latex(i) + r"&" + latex(round(tk[i],_sage_const_1 )) + r"&" + latex(round(yk[i],_sage_const_4 )) + r"\\"
  tableEuler+=r"\end{tabular}"
except:
 _st_.goboom(_sage_const_341 )
_st_.blockend()
try:
 _st_.inline(_sage_const_22 , tableEuler)
except:
 _st_.goboom(_sage_const_343 )
_st_.blockbegin()
try:
  #tiếp tính toán ở đoạn trên
  tp=_sage_const_1p15 
  zk1=zip(tk,yk) # zip: couple pairs of values of the two arrays
  #R = PolynomialRing(RR, "t") #RR: real numerical number
  R = PolynomialRing(QQ, "t") #QQ: symbolic number
  Lagrange_1 = R.lagrange_polynomial(zk1)
  bangNewton = R.divided_difference(zk1, full_table=True)
  plotL1=plot(Lagrange_1, (tk[_sage_const_0 ]), (tk[n-_sage_const_1 ]), color='red', legend_label='$\mathcal{L}_3(x)$')
  plotfxk1=list_plot(zk1, size=_sage_const_50 , legend_label='($t_k$,$y_k$)')
 
  # Now change the full table from Sagemath to my form of representing table
  bang1=list(list(i for i in range(j,n)) for j in range(n))
  for j in range(n):
     for i in range(j,n):
         bang1[j][i-j]=bangNewton[i][j]
  # Now create the Latex table
  tableNewton=r'\begin{tabular}{l|c|' # first column: k, second column: x_k
  for i in range(n): tableNewton+='c' # n columns for finit difference order 0 to n
  tableNewton+=r'}'
  tableNewton+=r'$k$ & $t_k$ & $y_k$'
  # for i in range(n-1): tableNewton+=r' & f[$t_0,\cdots,t_'+str(i+1)+r'$]'
  for i in range(_sage_const_1 ,n): tableNewton+=r' & $f_\Delta^'+str(i)+r'$'
  tableNewton+=r'\\ \hline'
  for i in range(n):
    tableNewton+=latex(i) + r' & ' + latex(round(tk[i],_sage_const_2 ))
    for j in range(i+_sage_const_1 ):
      tableNewton+= r' & ' + latex(round(bangNewton[i][j],_sage_const_2 ))
    for j in range(i+_sage_const_1 ,n): tableNewton+= r' & '
    tableNewton+= r'\\'
  tableNewton+=r'\end{tabular}'
except:
 _st_.goboom(_sage_const_377 )
_st_.blockend()
try:
 _st_.inline(_sage_const_23 , latex(Lagrange_1.expand()))
except:
 _st_.goboom(_sage_const_379 )
try:
 _st_.inline(_sage_const_24 , tableNewton)
except:
 _st_.goboom(_sage_const_383 )
try:
 _st_.inline(_sage_const_25 , latex(round(Lagrange_1(_sage_const_1p15 ),_sage_const_3 )))
except:
 _st_.goboom(_sage_const_385 )
_st_.blockbegin()
try:
  from sage.calculus.desolvers import desolve_rk4
  t,y=var('t y')
  zk_rk4=desolve_rk4(y/t-_sage_const_1 ,y,ics=[_sage_const_1 ,_sage_const_1 ],end_points=_sage_const_1p21 ,step=_sage_const_0p1 ) # nếu dùng đúng 1.2 thì nó lại bỏ số đó ra
  tk_rk4=[i for i,j in zk_rk4]
  yk_rk4=[j for i,j in zk_rk4]
  # Tạo table trong Latex
  tableRK4=r"\begin{tabular}{l|c|l}"
  tableRK4+=r"$k$ & $t_k$ & $y_k$ \\ \hline"
  for i in range(_sage_const_3 ):
    tableRK4+=latex(i) + r"&" + latex(round(tk_rk4[i],_sage_const_1 )) + r"&" + latex(round(yk_rk4[i],_sage_const_4 )) + r"\\"
  tableRK4+=r"\end{tabular}"
except:
 _st_.goboom(_sage_const_412 )
_st_.blockend()
try:
 _st_.inline(_sage_const_26 , tableRK4)
except:
 _st_.goboom(_sage_const_414 )
_st_.endofdoc()
