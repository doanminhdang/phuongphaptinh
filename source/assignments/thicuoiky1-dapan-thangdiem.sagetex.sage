## -*- encoding: utf-8 -*-
## This file (thicuoiky1-dapan-thangdiem.sagetex.sage) was *autogenerated* from thicuoiky1-dapan-thangdiem.tex with sagetex.sty version 2012/01/16 v2.3.3-69dcb0eb93de.
import sagetex
_st_ = sagetex.SageTeXProcessor('thicuoiky1-dapan-thangdiem', version='2012/01/16 v2.3.3-69dcb0eb93de', version_check=True)
_st_.blockbegin()
try:
  f4(x)=(x-1/3)^2*(x+2/3)
  x0=1
  f4diff=diff(f4,x)
except:
 _st_.goboom(80)
_st_.blockend()
try:
 _st_.inline(0, latex(f4(x).expand()))
except:
 _st_.goboom(82)
try:
 _st_.inline(1, latex(x0))
except:
 _st_.goboom(84)
_st_.blockbegin()
try:
 # Tạo hàm số
 def ppnewton_raphson(f,x0=0,n=10):
  # Tính nghiệm của hàm số f(x) theo phương pháp Newton-Raphson với điểm bắt đầu là x0, tối đa n bước
  # Yêu cầu: f là hàm số một biến f(x), x0 một số thực thuộc tập xác định của f(x), n là một số nguyên dương (>0)
  # Nếu không có các tham số x0, n: lấy mặc định là x0=0, và n=10
  # Kết quả được hiển thị làm tròn đến 5 chữ số thập phân
  decipoint=5
  f_diff=diff(f,x,1)
  xk=range(n+1)
  xk[0]=x0
  fxk=range(n)
  f_diff_xk=range(n)
  #deltaxk=range(n)
  #p_f=find_root(f,0,3) # find nearly exact root
  for i in range(n):
     fxk[i]=f(x=xk[i])
     f_diff_xk[i]=f_diff(x=xk[i])
     xk[i+1]=(f_diff_xk[i]*xk[i]-fxk[i])/f_diff_xk[i]
     #deltaxk[i]=abs(xk[i]-p_f)
  xk_disp=[round(xk[i],decipoint) for i in range(n)]
  fxk_disp=[round(fxk[i],decipoint) for i in range(n)]
  #deltaxk_disp=[round(deltaxk[i],decipoint) for i in range(n)]
  #p_f_disp=round(p_f,decipoint)
  # return fxk[n-1]
  return fxk_disp,xk_disp
 
 # Áp dụng để giải các bài toán
 n=6
 fxk_disp4,xk_disp4=ppnewton_raphson(f4,x0,n)
 #fxk_disp2,xk_disp2=ppnewton_raphson(f2,1,2)
 #fxk_disp3,xk_disp3=ppnewton_raphson(f3,1,2)
 
 # Trình bày các bảng kết quả
 tableN1=r"\begin{tabular}{c|cc}"
 tableN1+=r"$k$ & $x_k$ & $f(x_k)$ \\ \hline"
 for i in range(n):
   tableN1+=latex(i) + r"&" + latex(xk_disp4[i]) + r"&" + latex(fxk_disp4[i]) + r"\\"
 tableN1+=r"\end{tabular}"
except:
 _st_.goboom(131)
_st_.blockend()
try:
 _st_.inline(2, tableN1)
except:
 _st_.goboom(136)
try:
 _st_.inline(3, latex(f4diff(x).expand()))
except:
 _st_.goboom(152)
_st_.blockbegin()
try:
 latex.matrix_delimiters("[", "]")
 A=matrix([[1,5,7],[3,3,5],[2,1,8]])
 #A_rdf=matrix(RDF,[[1,5,7],[3,3,5],[2,1,8]])
 A_rdf=matrix(RDF,A)
 B=matrix([[32],[24],[28]])
 Xp=A\B
 #Xp=[1,2,3]
 Ainv=A.inverse()
 Ardfinv=A_rdf.inverse()
 #Ardfinv.round(3) # This will be used
 kA1=A_rdf.condition(1)
 kAinf=A_rdf.condition(infinity)
except:
 _st_.goboom(178)
_st_.blockend()
try:
 _st_.inline(4, latex(A))
except:
 _st_.goboom(183)
try:
 _st_.inline(5, latex(B))
except:
 _st_.goboom(183)
try:
 _st_.inline(6, latex(Ainv))
except:
 _st_.goboom(198)
try:
 _st_.inline(7, latex(Ardfinv.round(3)))
except:
 _st_.goboom(198)
try:
 _st_.inline(8, latex(Xp))
except:
 _st_.goboom(202)
_st_.blockbegin()
try:
 n=10
 tkx=[0.1*i for i in range(n+1)]
 tk=[0.1*i for i in range(n)]
 v0=5
 g=-9.81
 vt=[v0+g*tkx[i] for i in range(n+1)]
 xt=[0 for i in range(n+1)]
 for i in range(n):
  xt[i+1]=xt[i]+(vt[i+1]+vt[i])*0.1/2
 # Dữ liệu có sai số ngẫu nhiên
 #xk=[0.00000,0.46844,0.82762,1.14953,1.36673,1.47872,1.53896,1.41880,1.20203,0.88217,0.45938]
 xk=[0,0.5209,0.8226,1.1031,1.2477,1.2813,1.309,1.1464,0.8759,0.6008,0.1709]
 #xk=[0 for i in range(n+1)]
 #for i in range(n):
 # xk[i+1]=xt[i]+(vt[i+1]+vt[i])*0.1/2+0.1*random()
 # Dữ liệu chính xác
 #xk=xt
 tk2=[tk[i]^2 for i in range(n)]
 vk=[(xk[i+1]-xk[i])/0.1 for i in range(n)]
 zk=zip(tk,vk)
 plotdata=list_plot(zk, size=50, legend_label='($t_k$,$v_k$)')
 matA=matrix([[n,sum(tk)],[sum(tk),sum(tk2)]])
 tkvk=[tk[i]*vk[i] for i in range(n)]
 matB=vector([sum(vk),sum(tkvk)])
 a,b=N(matA\matB)
 t=var('t')
 hamxapxi=round(a,3)+round(b,3)*t
 plotline=plot(hamxapxi,0,tkx[n], color='red', legend_label='($y=A+Bt$)')
 
 tableVD5=r"\begin{tabular}{l|c|l}"
 tableVD5+=r"$k$ & $t_k$ & $v_k$ \\ \hline"
 for i in range(n):
   tableVD5+=latex(i) + r"&" + latex(round(tk[i],1)) + r"&" + latex(round(vk[i],3)) + r"\\"
 tableVD5+=r"\end{tabular}"
 
 tableTXk=r"\begin{tabular}{l|c|l}"
 tableTXk+=r"$k$ & $t_k$ & $x_k$ \\ \hline"
 for i in range(n+1):
   tableTXk+=latex(i) + r"&" + latex(round(tkx[i],1)) + r"&" + latex(round(xk[i],4)) + r"\\"
 tableTXk+=r"\end{tabular}"
 
except:
 _st_.goboom(259)
_st_.blockend()
try:
 _st_.inline(9, latex(n-1))
except:
 _st_.goboom(265)
try:
 _st_.inline(10, tableTXk)
except:
 _st_.goboom(270)
try:
 _st_.inline(11, tableVD5)
except:
 _st_.goboom(278)
try:
 _st_.inline(12, latex(hamxapxi(t)))
except:
 _st_.goboom(300)
try:
 _st_.plot(0, format='notprovided', _p_=plotdata+plotline)
except:
 _st_.goboom(304)
try:
 _st_.inline(13, latex(hamxapxi(t=0.85)))
except:
 _st_.goboom(306)
_st_.blockbegin()
try:
  n=4
  h=1/5
  tk=[h*i for i in range(n)]
  yk=range(n)
  yk[0]=1
  # Tính bằng công thức lặp
  #for i in range(n-1):
  #  yk[i+1]=yk[i]+h*(yk[i]+tk[i])
  # Tính bằng Euler solver có sẵn trong Sage
  t,y=var('t y')
  from sage.calculus.desolvers import eulers_method
  zk1=eulers_method(t+y,tk[0],yk[0],h,tk[0]+h*(n-1),algorithm="none")
  #yk=[[j] for i,j in zk1] # Báo lỗi phía sau: lệnh latex(round(yk[i],3)) không thực hiện được (TypeError: a float is required), vì dấu [] tạo ra matrix chứ không phải list
  yk=[j for i,j in zk1]
  # Tạo table trong Latex
  tableEuler=r"\begin{tabular}{l|c|l}"
  tableEuler+=r"$k$ & $t_k$ & $y_k$ \\ \hline"
  for i in range(n):
    tableEuler+=latex(i) + r"&" + latex(round(tk[i],1)) + r"&" + latex(round(yk[i],4)) + r"\\"
  tableEuler+=r"\end{tabular}"
except:
 _st_.goboom(356)
_st_.blockend()
try:
 _st_.inline(14, tableEuler)
except:
 _st_.goboom(358)
_st_.blockbegin()
try:
  #tiếp tính toán ở đoạn trên
  tp=0.5
  zk1=zip(tk,yk) # zip: couple pairs of values of the two arrays
  #R = PolynomialRing(RR, "t") #RR: real numerical number
  R = PolynomialRing(QQ, "t") #QQ: symbolic number
  Lagrange_1 = R.lagrange_polynomial(zk1)
  bangNewton = R.divided_difference(zk1, full_table=True)
  plotL1=plot(Lagrange_1, (tk[0]), (tk[n-1]), color='red', legend_label='$\mathcal{L}_3(x)$')
  plotfxk1=list_plot(zk1, size=50, legend_label='($t_k$,$y_k$)')
 
  # Now change the full table from Sagemath to my form of representing table
  bang1=list(list(i for i in range(j,n)) for j in range(n))
  for j in range(n):
     for i in range(j,n):
         bang1[j][i-j]=bangNewton[i][j]
  # Now create the Latex table
  tableNewton=r'\begin{tabular}{l|c|' # first column: k, second column: x_k
  for i in range(n): tableNewton+='c' # n columns for finit difference order 0 to n
  tableNewton+=r'}'
  tableNewton+=r'$k$ & $t_k$ & $y_k$'
  # for i in range(n-1): tableNewton+=r' & f[$t_0,\cdots,t_'+str(i+1)+r'$]'
  for i in range(1,n): tableNewton+=r' & $f_\Delta^'+str(i)+r'$'
  tableNewton+=r'\\ \hline'
  for i in range(n):
    tableNewton+=latex(i) + r' & ' + latex(round(tk[i],2))
    for j in range(i+1):
      tableNewton+= r' & ' + latex(round(bangNewton[i][j],2))
    for j in range(i+1,n): tableNewton+= r' & '
    tableNewton+= r'\\'
  tableNewton+=r'\end{tabular}'
except:
 _st_.goboom(398)
_st_.blockend()
try:
 _st_.inline(15, latex(Lagrange_1.expand()))
except:
 _st_.goboom(400)
try:
 _st_.inline(16, tableNewton)
except:
 _st_.goboom(404)
try:
 _st_.inline(17, latex(round(Lagrange_1(0.5),3)))
except:
 _st_.goboom(406)
_st_.blockbegin()
try:
  from sage.calculus.desolvers import desolve_rk4
  t,y=var('t y')
  zk_rk4=desolve_rk4(t+y,y,ics=[0,1],end_points=0.41,step=0.2) # dùng đúng số 0.4 cũng được, nhưng có lúc nó lại bỏ số cuối ra
  tk_rk4=[i for i,j in zk_rk4]
  yk_rk4=[j for i,j in zk_rk4]
  # Tạo table trong Latex
  tableRK4=r"\begin{tabular}{l|c|l}"
  tableRK4+=r"$k$ & $t_k$ & $y_k$ \\ \hline"
  for i in range(3):
    tableRK4+=latex(i) + r"&" + latex(round(tk_rk4[i],1)) + r"&" + latex(round(yk_rk4[i],4)) + r"\\"
  tableRK4+=r"\end{tabular}"
except:
 _st_.goboom(441)
_st_.blockend()
try:
 _st_.inline(18, tableRK4)
except:
 _st_.goboom(443)
_st_.endofdoc()
