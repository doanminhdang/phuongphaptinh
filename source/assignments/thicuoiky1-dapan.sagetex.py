## -*- encoding: utf-8 -*-
# This file was *autogenerated* from the file thicuoiky1-dapan.sagetex.sage.
from sage.all_cmdline import *   # import sage library
_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_7 = Integer(7); _sage_const_6 = Integer(6); _sage_const_5 = Integer(5); _sage_const_4 = Integer(4); _sage_const_328 = Integer(328); _sage_const_399 = Integer(399); _sage_const_1p1464 = RealNumber('1.1464'); _sage_const_8 = Integer(8); _sage_const_243 = Integer(243); _sage_const_182 = Integer(182); _sage_const_0p41 = RealNumber('0.41'); _sage_const_28 = Integer(28); _sage_const_330 = Integer(330); _sage_const_24 = Integer(24); _sage_const_0p8226 = RealNumber('0.8226'); _sage_const_136 = Integer(136); _sage_const_131 = Integer(131); _sage_const_186 = Integer(186); _sage_const_84 = Integer(84); _sage_const_0p85 = RealNumber('0.85'); _sage_const_80 = Integer(80); _sage_const_82 = Integer(82); _sage_const_0p1 = RealNumber('0.1'); _sage_const_364 = Integer(364); _sage_const_0p2 = RealNumber('0.2'); _sage_const_0p5 = RealNumber('0.5'); _sage_const_401 = Integer(401); _sage_const_1p1031 = RealNumber('1.1031'); _sage_const_1p2813 = RealNumber('1.2813'); _sage_const_366 = Integer(366); _sage_const_0p5209 = RealNumber('0.5209'); _sage_const_0p6008 = RealNumber('0.6008'); _sage_const_262 = Integer(262); _sage_const_1p309 = RealNumber('1.309'); _sage_const_254 = Integer(254); _sage_const_372 = Integer(372); _sage_const_278 = Integer(278); _sage_const_264 = Integer(264); _sage_const_13 = Integer(13); _sage_const_12 = Integer(12); _sage_const_11 = Integer(11); _sage_const_10 = Integer(10); _sage_const_17 = Integer(17); _sage_const_16 = Integer(16); _sage_const_15 = Integer(15); _sage_const_1p2477 = RealNumber('1.2477'); _sage_const_9p81 = RealNumber('9.81'); _sage_const_32 = Integer(32); _sage_const_276 = Integer(276); _sage_const_50 = Integer(50); _sage_const_0p1709 = RealNumber('0.1709'); _sage_const_167 = Integer(167); _sage_const_370 = Integer(370); _sage_const_162 = Integer(162); _sage_const_9 = Integer(9); _sage_const_18 = Integer(18); _sage_const_0p8759 = RealNumber('0.8759'); _sage_const_142 = Integer(142); _sage_const_14 = Integer(14); _sage_const_249 = Integer(249)## This file (thicuoiky1-dapan.sagetex.sage) was *autogenerated* from thicuoiky1-dapan.tex with sagetex.sty version 2012/01/16 v2.3.3-69dcb0eb93de.
import sagetex
_st_ = sagetex.SageTeXProcessor('thicuoiky1-dapan', version='2012/01/16 v2.3.3-69dcb0eb93de', version_check=True)
_st_.blockbegin()
try:
  __tmp__=var("x"); f4 = symbolic_expression((x-_sage_const_1 /_sage_const_3 )**_sage_const_2 *(x+_sage_const_2 /_sage_const_3 )).function(x)
  x0=_sage_const_1 
  f4diff=diff(f4,x)
except:
 _st_.goboom(_sage_const_80 )
_st_.blockend()
try:
 _st_.inline(_sage_const_0 , latex(f4(x).expand()))
except:
 _st_.goboom(_sage_const_82 )
try:
 _st_.inline(_sage_const_1 , latex(x0))
except:
 _st_.goboom(_sage_const_84 )
_st_.blockbegin()
try:
 # Tạo hàm số
 def ppnewton_raphson(f,x0=_sage_const_0 ,n=_sage_const_10 ):
  # Tính nghiệm của hàm số f(x) theo phương pháp Newton-Raphson với điểm bắt đầu là x0, tối đa n bước
  # Yêu cầu: f là hàm số một biến f(x), x0 một số thực thuộc tập xác định của f(x), n là một số nguyên dương (>0)
  # Nếu không có các tham số x0, n: lấy mặc định là x0=0, và n=10
  # Kết quả được hiển thị làm tròn đến 5 chữ số thập phân
  decipoint=_sage_const_5 
  f_diff=diff(f,x,_sage_const_1 )
  xk=range(n+_sage_const_1 )
  xk[_sage_const_0 ]=x0
  fxk=range(n)
  f_diff_xk=range(n)
  #deltaxk=range(n)
  #p_f=find_root(f,0,3) # find nearly exact root
  for i in range(n):
     fxk[i]=f(x=xk[i])
     f_diff_xk[i]=f_diff(x=xk[i])
     xk[i+_sage_const_1 ]=(f_diff_xk[i]*xk[i]-fxk[i])/f_diff_xk[i]
     #deltaxk[i]=abs(xk[i]-p_f)
  xk_disp=[round(xk[i],decipoint) for i in range(n)]
  fxk_disp=[round(fxk[i],decipoint) for i in range(n)]
  #deltaxk_disp=[round(deltaxk[i],decipoint) for i in range(n)]
  #p_f_disp=round(p_f,decipoint)
  # return fxk[n-1]
  return fxk_disp,xk_disp
 
 # Áp dụng để giải các bài toán
 n=_sage_const_6 
 fxk_disp4,xk_disp4=ppnewton_raphson(f4,x0,n)
 #fxk_disp2,xk_disp2=ppnewton_raphson(f2,1,2)
 #fxk_disp3,xk_disp3=ppnewton_raphson(f3,1,2)
 
 # Trình bày các bảng kết quả
 tableN1=r"\begin{tabular}{c|cc}"
 tableN1+=r"$k$ & $x_k$ & $f(x_k)$ \\ \hline"
 for i in range(n):
   tableN1+=latex(i) + r"&" + latex(xk_disp4[i]) + r"&" + latex(fxk_disp4[i]) + r"\\"
 tableN1+=r"\end{tabular}"
except:
 _st_.goboom(_sage_const_131 )
_st_.blockend()
try:
 _st_.inline(_sage_const_2 , tableN1)
except:
 _st_.goboom(_sage_const_136 )
try:
 _st_.inline(_sage_const_3 , latex(f4diff(x).expand()))
except:
 _st_.goboom(_sage_const_142 )
_st_.blockbegin()
try:
 latex.matrix_delimiters("[", "]")
 A=matrix([[_sage_const_1 ,_sage_const_5 ,_sage_const_7 ],[_sage_const_3 ,_sage_const_3 ,_sage_const_5 ],[_sage_const_2 ,_sage_const_1 ,_sage_const_8 ]])
 #A_rdf=matrix(RDF,[[1,5,7],[3,3,5],[2,1,8]])
 A_rdf=matrix(RDF,A)
 B=matrix([[_sage_const_32 ],[_sage_const_24 ],[_sage_const_28 ]])
 Xp=A * BackslashOperator() * B
 #Xp=[1,2,3]
 Ainv=A.inverse()
 Ardfinv=A_rdf.inverse()
 #Ardfinv.round(3) # This will be used
 kA1=A_rdf.condition(_sage_const_1 )
 kAinf=A_rdf.condition(infinity)
except:
 _st_.goboom(_sage_const_162 )
_st_.blockend()
try:
 _st_.inline(_sage_const_4 , latex(A))
except:
 _st_.goboom(_sage_const_167 )
try:
 _st_.inline(_sage_const_5 , latex(B))
except:
 _st_.goboom(_sage_const_167 )
try:
 _st_.inline(_sage_const_6 , latex(Ainv))
except:
 _st_.goboom(_sage_const_182 )
try:
 _st_.inline(_sage_const_7 , latex(Ardfinv.round(_sage_const_3 )))
except:
 _st_.goboom(_sage_const_182 )
try:
 _st_.inline(_sage_const_8 , latex(Xp))
except:
 _st_.goboom(_sage_const_186 )
_st_.blockbegin()
try:
 n=_sage_const_10 
 tkx=[_sage_const_0p1 *i for i in range(n+_sage_const_1 )]
 tk=[_sage_const_0p1 *i for i in range(n)]
 v0=_sage_const_5 
 g=-_sage_const_9p81 
 vt=[v0+g*tkx[i] for i in range(n+_sage_const_1 )]
 xt=[_sage_const_0  for i in range(n+_sage_const_1 )]
 for i in range(n):
  xt[i+_sage_const_1 ]=xt[i]+(vt[i+_sage_const_1 ]+vt[i])*_sage_const_0p1 /_sage_const_2 
 # Dữ liệu có sai số ngẫu nhiên
 #xk=[0.00000,0.46844,0.82762,1.14953,1.36673,1.47872,1.53896,1.41880,1.20203,0.88217,0.45938]
 xk=[_sage_const_0 ,_sage_const_0p5209 ,_sage_const_0p8226 ,_sage_const_1p1031 ,_sage_const_1p2477 ,_sage_const_1p2813 ,_sage_const_1p309 ,_sage_const_1p1464 ,_sage_const_0p8759 ,_sage_const_0p6008 ,_sage_const_0p1709 ]
 #xk=[0 for i in range(n+1)]
 #for i in range(n):
 # xk[i+1]=xt[i]+(vt[i+1]+vt[i])*0.1/2+0.1*random()
 # Dữ liệu chính xác
 #xk=xt
 tk2=[tk[i]**_sage_const_2  for i in range(n)]
 vk=[(xk[i+_sage_const_1 ]-xk[i])/_sage_const_0p1  for i in range(n)]
 zk=zip(tk,vk)
 plotdata=list_plot(zk, size=_sage_const_50 , legend_label='($t_k$,$v_k$)')
 matA=matrix([[n,sum(tk)],[sum(tk),sum(tk2)]])
 tkvk=[tk[i]*vk[i] for i in range(n)]
 matB=vector([sum(vk),sum(tkvk)])
 a,b=N(matA * BackslashOperator() * matB)
 t=var('t')
 hamxapxi=round(a,_sage_const_3 )+round(b,_sage_const_3 )*t
 plotline=plot(hamxapxi,_sage_const_0 ,tkx[n], color='red', legend_label='($y=A+Bt$)')
 
 tableVD5=r"\begin{tabular}{l|c|l}"
 tableVD5+=r"$k$ & $t_k$ & $v_k$ \\ \hline"
 for i in range(n):
   tableVD5+=latex(i) + r"&" + latex(round(tk[i],_sage_const_1 )) + r"&" + latex(round(vk[i],_sage_const_3 )) + r"\\"
 tableVD5+=r"\end{tabular}"
 
 tableTXk=r"\begin{tabular}{l|c|l}"
 tableTXk+=r"$k$ & $t_k$ & $x_k$ \\ \hline"
 for i in range(n+_sage_const_1 ):
   tableTXk+=latex(i) + r"&" + latex(round(tkx[i],_sage_const_1 )) + r"&" + latex(round(xk[i],_sage_const_4 )) + r"\\"
 tableTXk+=r"\end{tabular}"
 
except:
 _st_.goboom(_sage_const_243 )
_st_.blockend()
try:
 _st_.inline(_sage_const_9 , latex(n-_sage_const_1 ))
except:
 _st_.goboom(_sage_const_249 )
try:
 _st_.inline(_sage_const_10 , tableTXk)
except:
 _st_.goboom(_sage_const_254 )
try:
 _st_.inline(_sage_const_11 , tableVD5)
except:
 _st_.goboom(_sage_const_262 )
try:
 _st_.inline(_sage_const_12 , latex(hamxapxi(t)))
except:
 _st_.goboom(_sage_const_264 )
try:
 _st_.plot(_sage_const_0 , format='notprovided', _p_=plotdata+plotline)
except:
 _st_.goboom(_sage_const_276 )
try:
 _st_.inline(_sage_const_13 , latex(hamxapxi(t=_sage_const_0p85 )))
except:
 _st_.goboom(_sage_const_278 )
_st_.blockbegin()
try:
  n=_sage_const_4 
  h=_sage_const_1 /_sage_const_5 
  tk=[h*i for i in range(n)]
  yk=range(n)
  yk[_sage_const_0 ]=_sage_const_1 
  # Tính bằng công thức lặp
  #for i in range(n-1):
  #  yk[i+1]=yk[i]+h*(yk[i]+tk[i])
  # Tính bằng Euler solver có sẵn trong Sage
  t,y=var('t y')
  from sage.calculus.desolvers import eulers_method
  zk1=eulers_method(t+y,tk[_sage_const_0 ],yk[_sage_const_0 ],h,tk[_sage_const_0 ]+h*(n-_sage_const_1 ),algorithm="none")
  #yk=[[j] for i,j in zk1] # Báo lỗi phía sau: lệnh latex(round(yk[i],3)) không thực hiện được (TypeError: a float is required), vì dấu [] tạo ra matrix chứ không phải list
  yk=[j for i,j in zk1]
  # Tạo table trong Latex
  tableEuler=r"\begin{tabular}{l|c|l}"
  tableEuler+=r"$k$ & $t_k$ & $y_k$ \\ \hline"
  for i in range(n):
    tableEuler+=latex(i) + r"&" + latex(round(tk[i],_sage_const_1 )) + r"&" + latex(round(yk[i],_sage_const_4 )) + r"\\"
  tableEuler+=r"\end{tabular}"
except:
 _st_.goboom(_sage_const_328 )
_st_.blockend()
try:
 _st_.inline(_sage_const_14 , tableEuler)
except:
 _st_.goboom(_sage_const_330 )
_st_.blockbegin()
try:
  #tiếp tính toán ở đoạn trên
  tp=_sage_const_0p5 
  zk1=zip(tk,yk) # zip: couple pairs of values of the two arrays
  #R = PolynomialRing(RR, "t") #RR: real numerical number
  R = PolynomialRing(QQ, "t") #QQ: symbolic number
  Lagrange_1 = R.lagrange_polynomial(zk1)
  bangNewton = R.divided_difference(zk1, full_table=True)
  plotL1=plot(Lagrange_1, (tk[_sage_const_0 ]), (tk[n-_sage_const_1 ]), color='red', legend_label='$\mathcal{L}_3(x)$')
  plotfxk1=list_plot(zk1, size=_sage_const_50 , legend_label='($t_k$,$y_k$)')
 
  # Now change the full table from Sagemath to my form of representing table
  bang1=list(list(i for i in range(j,n)) for j in range(n))
  for j in range(n):
     for i in range(j,n):
         bang1[j][i-j]=bangNewton[i][j]
  # Now create the Latex table
  tableNewton=r'\begin{tabular}{l|c|' # first column: k, second column: x_k
  for i in range(n): tableNewton+='c' # n columns for finit difference order 0 to n
  tableNewton+=r'}'
  tableNewton+=r'$k$ & $t_k$ & $y_k$'
  # for i in range(n-1): tableNewton+=r' & f[$t_0,\cdots,t_'+str(i+1)+r'$]'
  for i in range(_sage_const_1 ,n): tableNewton+=r' & $f_\Delta^'+str(i)+r'$'
  tableNewton+=r'\\ \hline'
  for i in range(n):
    tableNewton+=latex(i) + r' & ' + latex(round(tk[i],_sage_const_2 ))
    for j in range(i+_sage_const_1 ):
      tableNewton+= r' & ' + latex(round(bangNewton[i][j],_sage_const_2 ))
    for j in range(i+_sage_const_1 ,n): tableNewton+= r' & '
    tableNewton+= r'\\'
  tableNewton+=r'\end{tabular}'
except:
 _st_.goboom(_sage_const_364 )
_st_.blockend()
try:
 _st_.inline(_sage_const_15 , latex(Lagrange_1.expand()))
except:
 _st_.goboom(_sage_const_366 )
try:
 _st_.inline(_sage_const_16 , tableNewton)
except:
 _st_.goboom(_sage_const_370 )
try:
 _st_.inline(_sage_const_17 , latex(round(Lagrange_1(_sage_const_0p5 ),_sage_const_3 )))
except:
 _st_.goboom(_sage_const_372 )
_st_.blockbegin()
try:
  from sage.calculus.desolvers import desolve_rk4
  t,y=var('t y')
  zk_rk4=desolve_rk4(t+y,y,ics=[_sage_const_0 ,_sage_const_1 ],end_points=_sage_const_0p41 ,step=_sage_const_0p2 ) # dùng đúng số 0.4 cũng được, nhưng có lúc nó lại bỏ số cuối ra
  tk_rk4=[i for i,j in zk_rk4]
  yk_rk4=[j for i,j in zk_rk4]
  # Tạo table trong Latex
  tableRK4=r"\begin{tabular}{l|c|l}"
  tableRK4+=r"$k$ & $t_k$ & $y_k$ \\ \hline"
  for i in range(_sage_const_3 ):
    tableRK4+=latex(i) + r"&" + latex(round(tk_rk4[i],_sage_const_1 )) + r"&" + latex(round(yk_rk4[i],_sage_const_4 )) + r"\\"
  tableRK4+=r"\end{tabular}"
except:
 _st_.goboom(_sage_const_399 )
_st_.blockend()
try:
 _st_.inline(_sage_const_18 , tableRK4)
except:
 _st_.goboom(_sage_const_401 )
_st_.endofdoc()
