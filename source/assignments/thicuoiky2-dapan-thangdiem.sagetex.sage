## -*- encoding: utf-8 -*-
## This file (thicuoiky2-dapan-thangdiem.sagetex.sage) was *autogenerated* from thicuoiky2-dapan-thangdiem.tex with sagetex.sty version 2012/01/16 v2.3.3-69dcb0eb93de.
import sagetex
_st_ = sagetex.SageTeXProcessor('thicuoiky2-dapan-thangdiem', version='2012/01/16 v2.3.3-69dcb0eb93de', version_check=True)
_st_.blockbegin()
try:
  f4(x)=(x+2/3)^2*(x-4/3)
  x0=1
  f4diff=diff(f4,x)
  g1(x)=(x^3-f4(x))^(1/3)
  g1=g1.expand()
  g1diff=diff(g1,x)
  g1diff2=diff(g1,x,2)
except:
 _st_.goboom(85)
_st_.blockend()
try:
 _st_.inline(0, latex(f4(x).expand()))
except:
 _st_.goboom(87)
try:
 _st_.inline(1, latex(x0))
except:
 _st_.goboom(89)
_st_.blockbegin()
try:
 # Tạo hàm số
 def ppnewton_raphson(f,x0=0,n=10):
  # Tính nghiệm của hàm số f(x) theo phương pháp Newton-Raphson với điểm bắt đầu là x0, tối đa n bước
  # Yêu cầu: f là hàm số một biến f(x), x0 một số thực thuộc tập xác định của f(x), n là một số nguyên dương (>0)
  # Nếu không có các tham số x0, n: lấy mặc định là x0=0, và n=10
  # Kết quả được hiển thị làm tròn đến 5 chữ số thập phân
  decipoint=4
  f_diff=diff(f,x,1)
  xk=range(n+1)
  xk[0]=x0
  fxk=range(n)
  f_diff_xk=range(n)
  #deltaxk=range(n)
  #p_f=find_root(f,0,3) # find nearly exact root
  for i in range(n):
     fxk[i]=f(x=xk[i])
     f_diff_xk[i]=f_diff(x=xk[i])
     xk[i+1]=(f_diff_xk[i]*xk[i]-fxk[i])/f_diff_xk[i]
     #deltaxk[i]=abs(xk[i]-p_f)
  xk_disp=[round(xk[i],decipoint) for i in range(n)]
  fxk_disp=[round(fxk[i],decipoint) for i in range(n)]
  #deltaxk_disp=[round(deltaxk[i],decipoint) for i in range(n)]
  #p_f_disp=round(p_f,decipoint)
  # return fxk[n-1]
  return fxk_disp,xk_disp
 
 # Áp dụng để giải các bài toán
 n=5
 fxk_disp4,xk_disp4=ppnewton_raphson(f4,x0,n)
 #fxk_disp2,xk_disp2=ppnewton_raphson(f2,1,2)
 #fxk_disp3,xk_disp3=ppnewton_raphson(f3,1,2)
 
 # Trình bày các bảng kết quả
 tableN1=r"\begin{tabular}{c|cc}"
 tableN1+=r"$k$ & $x_k$ & $f(x_k)$ \\ \hline"
 for i in range(n):
   tableN1+=latex(i) + r"&" + latex(xk_disp4[i]) + r"&" + latex(fxk_disp4[i]) + r"\\"
 tableN1+=r"\end{tabular}"
except:
 _st_.goboom(136)
_st_.blockend()
try:
 _st_.inline(2, tableN1)
except:
 _st_.goboom(141)
try:
 _st_.inline(3, latex(g1(x).expand()))
except:
 _st_.goboom(155)
try:
 _st_.inline(4, latex(g1diff(x).expand()))
except:
 _st_.goboom(155)
try:
 _st_.inline(5, latex(round(g1(x=1),3)))
except:
 _st_.goboom(158)
try:
 _st_.inline(6, latex(round(g1(x=2),3)))
except:
 _st_.goboom(158)
try:
 _st_.inline(7, latex(g1diff2(x)))
except:
 _st_.goboom(160)
try:
 _st_.inline(8, latex(round(g1diff(x=1),3)))
except:
 _st_.goboom(160)
try:
 _st_.inline(9, latex(round(g1diff(x=1),3)))
except:
 _st_.goboom(160)
try:
 _st_.inline(10, latex(round(g1diff(x=1),3)))
except:
 _st_.goboom(160)
_st_.blockbegin()
try:
 latex.matrix_delimiters("[", "]")
 A=matrix([[3,1,-1],[1,4,1],[1,-2,-5]])
 #A_rdf=matrix(RDF,[[3,1,-1],[1,4,1],[1,-2,-5]]) # lệnh tính condition() chỉ có với ma trận real-double-float, nhưng dùng ma trận RDF thì lại không giải được phương trình bằng kiểu lệnh A\B hoặc A.solve_right(B). Sẽ fix sau.
 A_rdf=matrix(RDF,A)
 B=matrix([[5],[4],[4]])
 x,y,z=var('x y z')
 X=matrix([[x],[y],[z]])
 Xp=A\B
 #Xp=[1,2,3]
 Ainv=A.inverse()
 Ardfinv=A_rdf.inverse()
 #Ardfinv.round(3) # This will be used
 kA1=A_rdf.condition(1)
 kAinf=A_rdf.condition(infinity)
except:
 _st_.goboom(194)
_st_.blockend()
try:
 _st_.inline(11, latex(Ainv))
except:
 _st_.goboom(225)
try:
 _st_.inline(12, latex(Ardfinv.round(3)))
except:
 _st_.goboom(225)
try:
 _st_.inline(13, latex(kA1))
except:
 _st_.goboom(226)
try:
 _st_.inline(14, latex(kAinf))
except:
 _st_.goboom(227)
try:
 _st_.inline(15, latex(X))
except:
 _st_.goboom(229)
try:
 _st_.inline(16, latex(Xp))
except:
 _st_.goboom(229)
_st_.blockbegin()
try:
 n=10
 tkx=[0.1*i for i in range(n+1)]
 tk=[0.1*i for i in range(n)]
 v0=-2
 g=9.81
 vt=[v0+g*tkx[i] for i in range(n+1)]
 xt=[0 for i in range(n+1)]
 for i in range(n):
  xt[i+1]=xt[i]+(vt[i+1]+vt[i])*0.1/2
 # Dữ liệu có sai số ngẫu nhiên
 xk=[0,-0.2,-0.189,-0.1929,0.0039,0.1863,0.6058,0.9755,1.5224,2.1542,2.8829]
 #xk=[0 for i in range(n+1)]
 #for i in range(n):
 # xk[i+1]=xt[i]+(vt[i+1]+vt[i])*0.1/2+(0.1*random()-0.05)
 # Dữ liệu chính xác
 #xk=xt
 tk2=[tk[i]^2 for i in range(n)]
 vk=[(xk[i+1]-xk[i])/0.1 for i in range(n)]
 zk=zip(tk,vk)
 plotdata=list_plot(zk, size=50, legend_label='($t_k$,$v_k$)')
 matA=matrix([[n,sum(tk)],[sum(tk),sum(tk2)]])
 tkvk=[tk[i]*vk[i] for i in range(n)]
 matB=vector([sum(vk),sum(tkvk)])
 a,b=N(matA\matB)
 t=var('t')
 hamxapxi=round(a,3)+round(b,3)*t
 plotline=plot(hamxapxi,0,tkx[n], color='red', legend_label='($y=A+Bt$)')
 
 tableVD5=r"\begin{tabular}{l|c|l}"
 tableVD5+=r"$k$ & $t_k$ & $v_k$ \\ \hline"
 for i in range(n):
   tableVD5+=latex(i) + r"&" + latex(round(tk[i],1)) + r"&" + latex(round(vk[i],3)) + r"\\"
 tableVD5+=r"\end{tabular}"
 
 tableTXk=r"\begin{tabular}{l|c|l}"
 tableTXk+=r"$k$ & $t_k$ & $x_k$ \\ \hline"
 for i in range(n+1):
   tableTXk+=latex(i) + r"&" + latex(round(tkx[i],1)) + r"&" + latex(round(xk[i],4)) + r"\\"
 tableTXk+=r"\end{tabular}"
 
except:
 _st_.goboom(285)
_st_.blockend()
try:
 _st_.inline(17, latex(n-1))
except:
 _st_.goboom(291)
try:
 _st_.inline(18, tableTXk)
except:
 _st_.goboom(296)
try:
 _st_.inline(19, tableVD5)
except:
 _st_.goboom(308)
try:
 _st_.inline(20, latex(hamxapxi(t)))
except:
 _st_.goboom(330)
try:
 _st_.plot(0, format='notprovided', _p_=plotdata+plotline)
except:
 _st_.goboom(334)
try:
 _st_.inline(21, latex(hamxapxi(t=0.85)))
except:
 _st_.goboom(336)
_st_.blockbegin()
try:
  n=4
  h=1/10
  tk=[1+h*i for i in range(n)]
  yk=range(n)
  yk[0]=1
  # Tính bằng công thức lặp
  #for i in range(n-1):
  #  yk[i+1]=yk[i]+h*(yk[i]+tk[i])
  # Tính bằng Euler solver có sẵn trong Sage
  t,y=var('t y')
  from sage.calculus.desolvers import eulers_method
  zk1=eulers_method(y/t-1,tk[0],yk[0],h,tk[0]+h*(n-1),algorithm="none")
  #yk=[[j] for i,j in zk1] # Báo lỗi phía sau: lệnh latex(round(yk[i],3)) không thực hiện được (TypeError: a float is required), vì dấu [] tạo ra matrix chứ không phải list
  yk=[j for i,j in zk1]
  # Tạo table trong Latex
  tableEuler=r"\begin{tabular}{l|c|l}"
  tableEuler+=r"$k$ & $t_k$ & $y_k$ \\ \hline"
  for i in range(n):
    tableEuler+=latex(i) + r"&" + latex(round(tk[i],1)) + r"&" + latex(round(yk[i],4)) + r"\\"
  tableEuler+=r"\end{tabular}"
except:
 _st_.goboom(386)
_st_.blockend()
try:
 _st_.inline(22, tableEuler)
except:
 _st_.goboom(388)
_st_.blockbegin()
try:
  #tiếp tính toán ở đoạn trên
  tp=1.15
  zk1=zip(tk,yk) # zip: couple pairs of values of the two arrays
  #R = PolynomialRing(RR, "t") #RR: real numerical number
  R = PolynomialRing(QQ, "t") #QQ: symbolic number
  Lagrange_1 = R.lagrange_polynomial(zk1)
  bangNewton = R.divided_difference(zk1, full_table=True)
  plotL1=plot(Lagrange_1, (tk[0]), (tk[n-1]), color='red', legend_label='$\mathcal{L}_3(x)$')
  plotfxk1=list_plot(zk1, size=50, legend_label='($t_k$,$y_k$)')
 
  # Now change the full table from Sagemath to my form of representing table
  bang1=list(list(i for i in range(j,n)) for j in range(n))
  for j in range(n):
     for i in range(j,n):
         bang1[j][i-j]=bangNewton[i][j]
  # Now create the Latex table
  tableNewton=r'\begin{tabular}{l|c|' # first column: k, second column: x_k
  for i in range(n): tableNewton+='c' # n columns for finit difference order 0 to n
  tableNewton+=r'}'
  tableNewton+=r'$k$ & $t_k$ & $y_k$'
  # for i in range(n-1): tableNewton+=r' & f[$t_0,\cdots,t_'+str(i+1)+r'$]'
  for i in range(1,n): tableNewton+=r' & $f_\Delta^'+str(i)+r'$'
  tableNewton+=r'\\ \hline'
  for i in range(n):
    tableNewton+=latex(i) + r' & ' + latex(round(tk[i],2))
    for j in range(i+1):
      tableNewton+= r' & ' + latex(round(bangNewton[i][j],2))
    for j in range(i+1,n): tableNewton+= r' & '
    tableNewton+= r'\\'
  tableNewton+=r'\end{tabular}'
except:
 _st_.goboom(430)
_st_.blockend()
try:
 _st_.inline(23, latex(Lagrange_1.expand()))
except:
 _st_.goboom(432)
try:
 _st_.inline(24, tableNewton)
except:
 _st_.goboom(436)
try:
 _st_.inline(25, latex(round(Lagrange_1(1.15),3)))
except:
 _st_.goboom(438)
_st_.blockbegin()
try:
  from sage.calculus.desolvers import desolve_rk4
  t,y=var('t y')
  zk_rk4=desolve_rk4(y/t-1,y,ics=[1,1],end_points=1.21,step=0.1) # nếu dùng đúng 1.2 thì nó lại bỏ số đó ra
  tk_rk4=[i for i,j in zk_rk4]
  yk_rk4=[j for i,j in zk_rk4]
  # Tạo table trong Latex
  tableRK4=r"\begin{tabular}{l|c|l}"
  tableRK4+=r"$k$ & $t_k$ & $y_k$ \\ \hline"
  for i in range(3):
    tableRK4+=latex(i) + r"&" + latex(round(tk_rk4[i],1)) + r"&" + latex(round(yk_rk4[i],4)) + r"\\"
  tableRK4+=r"\end{tabular}"
except:
 _st_.goboom(472)
_st_.blockend()
try:
 _st_.inline(26, tableRK4)
except:
 _st_.goboom(474)
_st_.blockbegin()
try:
  n=4
  h=1/10
  tk=[1+h*i for i in range(n)]
  yk=range(n)
  yk[0]=1
  # Tính bằng công thức lặp
  #for i in range(n-1):
  #  yk[i+1]=yk[i]+h*(yk[i]+tk[i])
  # Tính bằng Euler solver có sẵn trong Sage
  t,y=var('t y')
  from sage.calculus.desolvers import eulers_method
  zk1=eulers_method(y/t-1.1,tk[0],yk[0],h,tk[0]+h*(n-1),algorithm="none")
  #yk=[[j] for i,j in zk1] # Báo lỗi phía sau: lệnh latex(round(yk[i],3)) không thực hiện được (TypeError: a float is required), vì dấu [] tạo ra matrix chứ không phải list
  yk=[j for i,j in zk1]
  # Tạo table trong Latex
  tableEuler=r"\begin{tabular}{l|c|l}"
  tableEuler+=r"$k$ & $t_k$ & $y_k$ \\ \hline"
  for i in range(n):
    tableEuler+=latex(i) + r"&" + latex(round(tk[i],1)) + r"&" + latex(round(yk[i],4)) + r"\\"
  tableEuler+=r"\end{tabular}"
except:
 _st_.goboom(511)
_st_.blockend()
try:
 _st_.inline(27, tableEuler)
except:
 _st_.goboom(513)
_st_.blockbegin()
try:
  #tiếp tính toán ở đoạn trên
  tp=1.15
  zk1=zip(tk,yk) # zip: couple pairs of values of the two arrays
  #R = PolynomialRing(RR, "t") #RR: real numerical number
  R = PolynomialRing(QQ, "t") #QQ: symbolic number
  Lagrange_1 = R.lagrange_polynomial(zk1)
  bangNewton = R.divided_difference(zk1, full_table=True)
  plotL1=plot(Lagrange_1, (tk[0]), (tk[n-1]), color='red', legend_label='$\mathcal{L}_3(x)$')
  plotfxk1=list_plot(zk1, size=50, legend_label='($t_k$,$y_k$)')
 
  # Now change the full table from Sagemath to my form of representing table
  bang1=list(list(i for i in range(j,n)) for j in range(n))
  for j in range(n):
     for i in range(j,n):
         bang1[j][i-j]=bangNewton[i][j]
  # Now create the Latex table
  tableNewton=r'\begin{tabular}{l|c|' # first column: k, second column: x_k
  for i in range(n): tableNewton+='c' # n columns for finit difference order 0 to n
  tableNewton+=r'}'
  tableNewton+=r'$k$ & $t_k$ & $y_k$'
  # for i in range(n-1): tableNewton+=r' & f[$t_0,\cdots,t_'+str(i+1)+r'$]'
  for i in range(1,n): tableNewton+=r' & $f_\Delta^'+str(i)+r'$'
  tableNewton+=r'\\ \hline'
  for i in range(n):
    tableNewton+=latex(i) + r' & ' + latex(round(tk[i],2))
    for j in range(i+1):
      tableNewton+= r' & ' + latex(round(bangNewton[i][j],2))
    for j in range(i+1,n): tableNewton+= r' & '
    tableNewton+= r'\\'
  tableNewton+=r'\end{tabular}'
except:
 _st_.goboom(555)
_st_.blockend()
try:
 _st_.inline(28, latex(Lagrange_1.expand()))
except:
 _st_.goboom(557)
try:
 _st_.inline(29, tableNewton)
except:
 _st_.goboom(561)
try:
 _st_.inline(30, latex(round(Lagrange_1(1.15),3)))
except:
 _st_.goboom(563)
_st_.blockbegin()
try:
  from sage.calculus.desolvers import desolve_rk4
  t,y=var('t y')
  zk_rk4=desolve_rk4(y/t-1.1,y,ics=[1,1],end_points=1.21,step=0.1) # nếu dùng đúng 1.2 thì nó lại bỏ số đó ra
  tk_rk4=[i for i,j in zk_rk4]
  yk_rk4=[j for i,j in zk_rk4]
  # Tạo table trong Latex
  tableRK4=r"\begin{tabular}{l|c|l}"
  tableRK4+=r"$k$ & $t_k$ & $y_k$ \\ \hline"
  for i in range(3):
    tableRK4+=latex(i) + r"&" + latex(round(tk_rk4[i],1)) + r"&" + latex(round(yk_rk4[i],4)) + r"\\"
  tableRK4+=r"\end{tabular}"
except:
 _st_.goboom(597)
_st_.blockend()
try:
 _st_.inline(31, tableRK4)
except:
 _st_.goboom(599)
_st_.endofdoc()
